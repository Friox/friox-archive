---
slug: msa-study
title: MSA
description: 마이크로서비스 아키텍처(MSA)는 애플리케이션을 독립적인 작은 서비스들로 분리하여 개발, 배포, 운영하는 소프트웨어 설계방식입니다. MSA의 개념과 장단점을 기준으로 모놀리식 아키텍처와 비교해보고, Spring에서 이를 구현하기 위한 프레임워크와 도구를 알아봅니다.
createAt: 2025-03-31
category: 개발
tags: [DevOps, SpringCloud, Eureka, Deepdive]
series: deepdive - MSA
---

> **kakao x goorm deepdive 백엔드 3회차**  
> 이 게시물은 해당 과정 참여 중 별도로 학습한 내용을 정리한 것입니다.

## MSA
- Micro Service Architecture
- 소프트웨어 개발방식 중 하나로, 커다란 어플리케이션을 독립적으로 배포, 운영하는 방식
- 할 수 있는대로 작은 서비스 단위로 나누어 개발하는 접근 방식이다.
- 각 서비스는 고유한 기능을 담당하며, 다른 서비스들과 통신하며 하나의 어플리케이션을 이룬다.  
    (API를 통해 통신함)
- 확장성, 유지보수 용이성, 독립적인 배포 가능성
- 서비스가 독립적이기 때문에 업데이트, 오류 발생 시 다른 서비스에 큰 영향이 없다

### 모놀로식
- 애플리케이션의 서비스들은 하나의 기술스택에 국한되는 경우가 많음.  
    (새로운 기술 도입 시 전체 애플리케이션에 영향을 줄 수 있다.)
- 하나를 확장하려면 전체 애플리케이션에 대해 확장해야 하므로 자원낭비가 발생할 수 있다.  
    (특정 서비스의 수요가 증가하면 전체 시스템의 자원을 증설해야한다.)
- 하나의 컴포넌트에 장애가 발생하면 전체 애플리케이션이 영향을 받을 수 있다.  
    (서비스의 신뢰성을 저하시키는 요인이 될 수 있다.)
- 단일 시스템에서 모든 로그와 성능 데이터를 추적할 수 있어서 모니터링이 비교적 간단하다.
- 다른 서비스가 모두 잘 작동해도 하나가 잘 안풀리면 배포 불가능 (배포주기 길어짐)

### 마이크로서비스
- 각 서비스는 독립적으로 개발되기때문에, 서비스 필요에 따라 적합한 기술스택을 선택할 수 있다.  
    (최신 기술을 신속하게 도입할 수 있다.)
- 필요한 서비스만 개별적으로 확장할 수 있어 자원 활용을 극대화 할 수 있다.  
    (트래픽이 높은 서비스에 매우 유리하다.)
- 서비스 간 의존성이 분리되어 있어 전체 시스템의 영향을 최소화 할 수 있다.  
    (각 서비스는 독립적으로 회복할 수 있어 전체 시스템의 가용성을 높일 수 있다.)
- 여러개의 독립적인 서비스로 구성되어 있기때문에 서비스 간 상태와 성능을 모니터링하기 힘들 수 있다.  
    (모니터링 시스템 구축에 노력이 필요하다, 복잡성 증대)
- 각각의 서비스는 독립 배포 가능 (모놀로식보다 배포주기가 훨씬 짧아질 수 있다.)

정리하면, MSA는 애플리케이션을 기능별로 나누어 각각 독립적으로 개발, 배포, 운영하는것.
각각의 기능들은 독립적이어서 기능 하나가 죽어도 애플리케이션은 정상작동함.

독립적인것이 항상 장점이 될순없다. MSA를 채택할 시 모니터링, 로깅, 인증 등 관리할 부분이 늘어나고
노드간 분산된 트랜잭션과 데이터 동기화 문제를 해결해야 한다.

- 직원 한명인 가게 또는 회사 (모놀로식)
- 직원 여러명인 가게 또는 회사 (MSA)

## 장단점 정리

### 모놀리식 아키텍처: 장점 🟢
- 개발 및 배포의 간단함 : 모든 기능이 하나의 코드베이스에 존재하기 때문에 초기 개발과 배포가 쉽다.
- 성능 : 서비스 간 네트워크 통신이 없기 때문에 전반적인 속도가 더 빠를 수 있다.
- 초기 프로젝트에 적합함 : 작은 규모의 프로젝트나 빠른 프로토타입 제작에 적합하다.
- 테스트 용이성 : 통합된 환경에서의 테스트가 간단하며, 디버깅도 상대적으로 쉽다.

### 모놀리식 아키텍처 : 단점 🔴
- 확장성 부족 : 특정 기능만 확장하는것은 구조상 불가능하며, 그러기 위해서는 전체 시스템을 확장해야한다.
- 유지보수 어려움 : 애플리케이션이 커질수록 코드베이스가 복잡해지고, 수정 시 전체 시스템에 영향 가능성.
- 기술 스택 제한 : 하나의 기술 스택에 종속되며, 새로운 기술 도입이 어렵다.
- 안정성 : 하나의 모듈 오류가 전체 시스템에 영향을 줄 수 있다.

### 모놀리식 아키텍처 도입시점
- 프로젝트 규모가 작고 요구사항이 명확할 때.
- 빠른 프로토타입 개발 시
- 팀이 분산 시스템 경험이 부족하고 단순한 구조를 선호할 때.

### MSA: 장점 🟢
- 유연한 확장성 : 필요한 서비스만 독립적으로 확장 가능하여 자원 효율성이 높다.
- 독립적인 개발 및 배포 : 각 서비스는 독립적으로 개발 및 배포할 수 있어서 빠른 업데이트와 유지보수 가능.
- 장애 격리 : 한 서비스의 장애가 전체 시스템에 영향을 주지 않으므로 안정성이 높다.
- 다양한 기술 활용 가능 : 서비스 별로 기술스택을 다르게 가져갈 수 있다.

### MSA: 단점 🔴
- 운영 복잡성 증가 : 여러 서비스를 관리해야 하므로 모니터링, 로깅, 배포 등 독립적인 구조에서 오는 단점 발생
- 통신 비용 증가 : 서비스 간 네트워크 통신으로 인해 지연시간 발생 가능.
- 데이터 일관성 문제 : 분산된 DB 간 동기화와 트랜잭션 관리가 어렵다.
- 초기 비용 증가 : 인프라 구축과 기술 학습 곡선이 높아 초기에는 힘들다.

### MSA 아키텍처 도입시점
- 애플리케이션 규모가 크고 지속적인 확장이 예상될 때.
- 높은 트래픽 처리와 유연한 확장이 필요한 경우
- 서비스가 클라우드 환경에서 운영될 때
- 다양한 기술 스택을 활용하거나 독립적인 팀 개발이 필요한 경우.

## MSA 구현 프레임워크 & 도구

### Spring Cloud
- MSA 구현을 위해 설계된 Spring의 확장 플랫폼
- 다양한 모듈과 도구를 제공하여 MSA의 복잡성을 줄이고 개발 및 운영을 간소화한다.
- 서비스 디스커버리 : Eureka와 같은 도구를 이용해 동적으로 서비스 위치를 관리.
- API 게이트웨이 : `Spring Cloud Gateway` 로 클라이언트 요청을 라우팅하고 로드밸런싱 수행
- 분산 추적 : `Sleuth`, `Zipkin` 으로 서비스 간 호출 추적
- 구성 관리 : `Spring Cloud Config` 로 중앙 집중식 설정 관리

### Eureka
- 넷플릭스가 개발한 서비스 디스커버리 도구
- `Spring Cloud Netflix` 모듈에서 제공됨
- MSA 환경에서 각 서비스의 위치(IP, Port)를 동적으로 관리하는 역할을 함
- Eureka Server : 마이크로서비스들의 정보가 저장되는 중앙 레지스트리
- Eureka Client : 각 마이크로서비스는 `Eureka Server` 에 자신의 정보를 저장
- 로드 밸런싱 및 장애 처리 : Eureka는 여러 인스턴스를 관리하며, 정상적인 인스턴스로 요청을 분배

> **💡 API Gateway**
> - Client와 백엔드 마이크로서비스 사이의 단일 진입점 역할을 함.
> - 여러 마이크로서비스와 직접 통신하지 않고 API Gateway를 통해 필요한 요청을 처리함.
> - 핵심은 라우팅이며, 추가적으로 인증, 권한 부여, 로깅 등의 공통 기능을 수행한다.
> - ⇒ 중앙제어 역할

> **💡 Load Balancer**
> - 서비스 간 트래픽 분산을 담당함.
> - 각 인스턴스의 상태를 주기적으로 체크하여 문제가 있는 인스턴스에는 트래픽을 보내지 않음.
> - 특정 인스턴스가 과부하 되지 않도록 조절함.
> - `API Gateway` 뒤에서 동작하거나 독립적으로 사용할 수 있음.
> - [분산 전략] 라운드 로빈 (Round Robin) : 순차적으로 순환 할당
> - [분산 전략] 최소 연결 (Least Connections) : 가장 적은 연결을 처리중인 쪽으로 할당
> - [분산 전략] 가중 라운드 로빈 (Weighted Round Robin) : 성능 가중치를 고려하여 분배
> - ⇒ 부하 관리

### 전체 흐름
1. Client가 API Gateway로 Request
2. API Gateway는 Eureka Server에 서비스 인스턴스 정보 조회
3. Load Balancer에게 정보 전달 후 적절한 Eureka Client 요청 전달
4. 서비스 인스턴스는 요청 처리 후 API Gateway를 통해 Client에게 응답 반환