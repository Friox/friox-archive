---
slug: deep-dive-20250409
title: React 기초 - 2
description: 임시
createAt: 2025-04-09
category: 학습일지
tags: [deepdive, react, frontend]
series: deepdive backend 3rd
---

`markdown:deepdive-info.md`

# Life Cycle

React 컴포넌트는 생성부터 소멸까지 일련의 생명주기(Lifecycle) 단계를 거친다.  
각 단계에서 특정 작업을 수행할 수 있도록 관련 메서드(클래스 컴포넌트) 또는 Hook(함수형 컴포넌트)이 제공된다.  
주요 생명주기 단계와 예시는 다음과 같다.

## 마운트 (Mounting)

컴포넌트 인스턴스가 생성되어 DOM에 삽입될 때 발생한다. 초기 설정, 데이터 로딩 등의 작업을 수행한다.

* **주요 메서드/Hook:**
  * 클래스: `constructor()`, `render()`, `componentDidMount()`
  * 함수형: 함수 본문 (`render`), `useState()`, `useEffect(..., [])`

```jsx
// 클래스 컴포넌트
import React, { Component } from 'react';

class ClassLifecycle extends Component {
  // constructor: 컴포넌트 생성 시 가장 먼저 호출됨. state 초기화, 메서드 바인딩 수행.
  constructor(props) {
    super(props); // 부모 클래스 생성자 호출 필수
    this.state = { data: null }; // state 초기화
  }

  // componentDidMount: 컴포넌트가 DOM에 마운트된 직후 호출됨.
  // 주로 초기 데이터 로딩(API 호출), 구독 설정 등에 사용.
  componentDidMount() {
    // 예: 데이터 로딩
    fetch('/api/data')
      .then(res => res.json())
      .then(data => this.setState({ data }));
  }

  // render: UI를 렌더링하는 메서드. props와 state를 기반으로 JSX 반환.
  // 순수 함수여야 하며, 부수 효과(side effect)를 발생시키면 안 됨.
  render() {
    return <div>{this.state.data ? 'Loaded' : 'Loading...'}</div>;
  }
}

// 함수형 컴포넌트
import React, { useState, useEffect } from 'react';

function FunctionalLifecycle() {
  // useState: 함수형 컴포넌트에서 state를 관리하는 Hook. [상태값, 상태설정함수] 반환.
  const [data, setData] = useState(null);

  // useEffect: 컴포넌트 렌더링 후 부수 효과(side effect)를 수행하는 Hook.
  // 두 번째 인자로 빈 배열([]) 전달 시, 마운트 시 1회만 실행 (componentDidMount와 유사).
  useEffect(() => {
    // 예: 데이터 로딩
    fetch('/api/data')
      .then(res => res.json())
      .then(data => setData(data));

    // useEffect의 반환 함수(cleanup function): 컴포넌트 언마운트 시 또는 다음 effect 실행 전에 호출됨.
    // 리소스 정리(타이머 해제, 구독 해제 등)에 사용 (componentWillUnmount와 유사).
    return () => {
      console.log('useEffect 정리함수');
    };
  }, []); // 빈 배열: 마운트 시 1회 실행

  // 함수 본문: 클래스의 render()와 유사. 렌더링 시마다 실행되어 JSX 반환.
  return <div>{data ? 'Loaded' : 'Loading...'}</div>;
}
```

## 업데이트 (Updating)

props 또는 state가 변경되어 컴포넌트가 리렌더링될 때 발생한다. 변경된 상태에 따라 DOM을 업데이트한다.

* **주요 메서드/Hook:**
  * 클래스: `shouldComponentUpdate()`, `render()`, `getSnapshotBeforeUpdate()`, `componentDidUpdate()`
  * 함수형: 함수 본문 (`render`), `useEffect(..., [deps])`

```jsx
// 클래스 컴포넌트
class ClassLifecycleUpdate extends Component {
  // ... (constructor, componentDidMount 등 생략)

  // shouldComponentUpdate: props 또는 state 변경 시 리렌더링 여부를 결정.
  // true 반환 시 리렌더링, false 반환 시 중단. 성능 최적화에 사용.
  shouldComponentUpdate(nextProps, nextState) {
    // 예: count prop이 변경될 때만 리렌더링
    return nextProps.count !== this.props.count;
  }

  // getSnapshotBeforeUpdate: render 후 DOM 업데이트 직전에 호출됨.
  // 업데이트 전의 DOM 상태(예: 스크롤 위치)를 캡처하여 componentDidUpdate에 전달.
  getSnapshotBeforeUpdate(prevProps, prevState) {
    // 예: 업데이트 전 스크롤 위치 등 저장
    return window.scrollY; // 여기서 반환된 값이 componentDidUpdate의 snapshot 인자로 전달됨
  }

  // componentDidUpdate: 컴포넌트 업데이트 완료 후 호출됨.
  // DOM 조작, 네트워크 요청 등에 사용. snapshot 값 활용 가능.
  // 조건 없이 setState 호출 시 무한 루프 주의
  componentDidUpdate(prevProps, prevState, snapshot) {
    if (prevProps.count !== this.props.count) {
      // 예: count 변경에 따른 추가 작업
    }
  }

  // render: 업데이트 시에도 호출되어 변경된 UI 반환.
  render() {
    return <div>{this.props.count}</div>;
  }
}

// 함수형 컴포넌트
function FunctionalLifecycleUpdate({ count }) {
  // 함수형 컴포넌트는 props나 state 변경 시 함수 본문 전체가 다시 실행됨 (render 역할).
  const [internalState, setInternalState] = useState(0);

  // useEffect: 두 번째 인자(의존성 배열)에 포함된 값이 변경될 때마다 effect 함수 실행.
  // componentDidUpdate와 유사하게 props/state 변경에 따른 부수 효과 처리.
  useEffect(() => {
    // 예: count 변경에 따른 추가 작업

    // cleanup 함수: 다음 effect 실행 전 또는 언마운트 시 호출됨.
    return () => {
      console.log('useEffect 정리함수');
    };
  }, [count]); // count가 변경될 때마다 이 effect 실행

  return <div>{count}</div>;
}

// React.memo를 사용하여 props 변경 시에만 리렌더링 (shouldComponentUpdate와 유사)
// const MemoizedFunctionalLifecycleUpdate = React.memo(FunctionalLifecycleUpdate);
```

## 언마운트 (Unmounting)

컴포넌트가 DOM에서 제거될 때 발생한다. 주로 설정했던 리소스(타이머, 구독 등)를 정리(cleanup)한다.

* **주요 메서드/Hook:**
  * 클래스: `componentWillUnmount()`
  * 함수형: `useEffect`의 반환 함수

```jsx
// 클래스 컴포넌트
class ClassLifecycleUnmount extends Component {
  constructor(props) {
    super(props);
    this.timerID = null;
  }
  componentDidMount() {
    // 예시: 마운트 시 타이머 설정
    this.timerID = setInterval(() => console.log('Class Timer Tick'), 1000);
  }
  // componentWillUnmount: 컴포넌트가 DOM에서 제거되기 직전에 호출됨.
  // 리소스 정리(타이머 해제, 구독 해제 등) 수행.
  componentWillUnmount() {
    // 예: 타이머 정리
    clearInterval(this.timerID);
  }
  render() {
    return <div>Class Component Will Unmount Soon.</div>;
  }
}

// 함수형 컴포넌트
function FunctionalLifecycleUnmount() {
  // useEffect: 마운트 시 effect 함수 실행.
  useEffect(() => {
    // 예시: 마운트 시 타이머 설정
    const timerID = setInterval(() => console.log('Functional Timer Tick'), 1000);

    // cleanup 함수: 컴포넌트 언마운트 시 호출됨 (componentWillUnmount와 동일 역할).
    return () => {
      // 예: 타이머 정리
      clearInterval(timerID);
    };
  }, []); // 빈 배열: 마운트 시 1회 실행, 언마운트 시 cleanup 함수 실행

  return <div>Functional Component Will Unmount Soon.</div>;
}
```

# Hooks

함수형 컴포넌트에서 상태(state) 관리, 생명주기 기능 등 클래스 컴포넌트의 기능을 사용할 수 있게 해주는 특별한 함수들.  
Hooks는 `use`로 시작하는 이름을 가지며, 몇 가지 규칙을 따라야 한다.  
(최상위 레벨에서만 호출, React 함수 컴포넌트 내에서만 호출 등)

## useEffect

`useEffect`는 컴포넌트 렌더링 이후에 어떤 부수 효과(side effects)를 수행하도록 설정하는 Hook이다.  
데이터 가져오기, 구독 설정, 수동 DOM 조작 등이 대표적인 부수 효과이다.

* **기본 구조:** `useEffect(didUpdate, dependencies?)`
  * `didUpdate`: 렌더링 이후 실행될 함수.
  * `dependencies` (선택 사항): 의존성 배열. 이 배열 안의 값이 변경될 때만 `didUpdate` 함수가 다시 실행된다.
    * 생략 시: 매 렌더링마다 실행.
    * `[]` (빈 배열): 마운트 시 1회만 실행.
    * `[dep1, dep2]`: `dep1` 또는 `dep2`가 변경될 때마다 실행.
* **정리(Cleanup) 함수:** `useEffect`의 `didUpdate` 함수가 다른 함수를 반환하면,  
이 함수는 다음 effect 실행 전 또는 컴포넌트 언마운트 시 호출되어 정리 작업을 수행한다.
```jsx
import React, { useState, useEffect } from 'react';
function TimerComponent() {
  const [seconds, setSeconds] = useState(0);

  // useEffect: 마운트 시 타이머 설정, 언마운트 시 타이머 정리
  useEffect(() => {

    // 1초마다 seconds 상태 업데이트
    const intervalId = setInterval(() => {
      setSeconds(prevSeconds => prevSeconds + 1);
    }, 1000);

    // cleanup 함수: 컴포넌트 언마운트 시 타이머 정리
    return () => {
      clearInterval(intervalId);
    };
  }, []); // 빈 배열: 마운트 시 1회만 실행
  return <div>Seconds: {seconds}</div>;
}
```

## useReducer

`useReducer`는 `useState`의 대안으로, 복잡한 상태 로직을 관리하는 데 더 적합한 Hook이다.  
특히 여러 하위 값으로 구성된 상태 객체나, 다음 상태가 이전 상태에 의존적인 경우 유용하다.

* **기본 구조:** `const [state, dispatch] = useReducer(reducer, initialArg, init?)`
  * `reducer`: `(state, action) => newState` 형태의 함수. 현재 상태와 액션을 받아 새로운 상태를 반환한다.
  * `initialArg`: 초기 상태 값.
  * `init` (선택 사항): 초기 상태를 지연 생성하는 함수.
  * `state`: 현재 상태 값.
  * `dispatch`: 액션 객체를 리듀서에게 전달하는 함수.  
    `dispatch({ type: 'ACTION_TYPE', ... })` 형태로 호출한다.

```jsx
import React, { useReducer } from 'react';

// 초기 상태 정의
const initialState = { count: 0 };

// 리듀서 함수: 상태 업데이트 로직 정의
function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 };
    case 'decrement':
      return { count: state.count - 1 };
    case 'reset':
      return initialState; // 초기 상태로 리셋
    default:
      throw new Error('Unknown action type');
  }
}

function Counter() {
  // useReducer 사용: 리듀서와 초기 상태 연결
  const [state, dispatch] = useReducer(reducer, initialState);

  return (
    <>
      Count: {state.count}
      {/* dispatch 함수로 액션 전달하여 상태 업데이트 요청 */}
      <button onClick={() => dispatch({ type: 'increment' })}>+</button>
      <button onClick={() => dispatch({ type: 'decrement' })}>-</button>
      <button onClick={() => dispatch({ type: 'reset' })}>Reset</button>
    </>
  );
}
```

## useMemo

`useMemo`는 **메모이제이션(memoization)** 된 값을 반환하는 Hook이다.  
의존성 배열의 값이 변경되지 않았다면, 이전에 계산된 값을 재사용하여 불필요한 계산을 방지하고 성능을 최적화한다.

* **기본 구조:** `const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);`
  * 첫 번째 인자: 값을 계산하는 생성 함수.
  * 두 번째 인자: 의존성 배열. 배열 안의 값이 변경될 때만 생성 함수가 다시 실행된다.

* **언제 사용하는가?**
  * 비용이 큰 계산 결과를 캐싱할 때.
  * 참조 동등성에 의존하는 자식 컴포넌트에게 전달되는 객체나 배열이 불필요하게 재생성되는 것을 방지할 때.

```jsx
import React, { useState, useMemo } from 'react';

function ExpensiveCalculationComponent({ num }) {
  // num이 변경될 때만 expensiveCalculation 함수 실행
  const calculationResult = useMemo(() => {
    let result = 0;
    // 예시: 복잡한 계산 (실제로는 더 오래 걸리는 작업)
    for (let i = 0; i < num * 10000000; i++) {
      result += 1;
    }
    return result;
  }, [num]); // num이 변경될 때만 재계산

  return (
    <div>
      <p>Number: {num}</p>
      <p>Calculation Result: {calculationResult}</p>
    </div>
  );
}

function App() {
  const [count, setCount] = useState(1);
  const [num, setNum] = useState(5);

  return (
    <div>
      {/* 이 버튼 클릭 시 App은 리렌더링되지만, num이 그대로면 ExpensiveCalculationComponent의 useMemo는 재계산 안 함 */}
      <button onClick={() => setCount(count + 1)}>Increment Count (triggers re-render)</button>
      <button onClick={() => setNum(num + 1)}>Increment Num (triggers calculation)</button>
      <p>App Count: {count}</p>
      <ExpensiveCalculationComponent num={num} />
    </div>
  );
}
```

## useCallback

`useCallback`은 **메모이제이션된 콜백 함수**를 반환하는 Hook이다.  
의존성 배열의 값이 변경되지 않았다면, 이전에 생성된 함수 인스턴스를 재사용한다.  
이는 불필요한 함수 재생성을 방지하여 성능 최적화에 도움을 준다.

* **기본 구조:** `const callback = useCallback(() => { doSomething(a, b); }, [a, b]);`
  * 첫 번째 인자: 메모이제이션할 콜백 함수.
  * 두 번째 인자: 의존성 배열. 배열 안의 값이 변경될 때만 콜백 함수가 새로 생성된다.

* **언제 사용하는가?**
  * `React.memo`로 최적화된 자식 컴포넌트에게 콜백 함수를 전달할 때.  
    (함수가 재생성되면 자식 컴포넌트가 불필요하게 리렌더링될 수 있음)
  * 콜백 함수가 다른 Hook(예: `useEffect`)의 의존성 배열에 포함될 때.

```jsx
import React, { useState, useCallback } from 'react';

// React.memo: props가 변경되지 않으면 리렌더링 방지
const ChildComponent = React.memo(({ onClick }) => {
  return <button onClick={onClick}>Click</button>;
});

function ParentComponent() {
  const [count, setCount] = useState(0);

  // useCallback으로 handleClick 함수 메모이제이션
  // ParentComponent가 리렌더링되어도 count가 변경되지 않으면 동일한 함수 인스턴스 유지
  const handleClick = useCallback(() => {
    console.log('Button clicked!');
    // 만약 여기서 count 상태를 사용한다면 의존성 배열에 추가해야 함: [count]
  }, []); // 의존성 없음: 항상 동일한 함수 반환

  return (
    <div>
      <p>Parent Count: {count}</p>
      {/* 이 버튼 클릭 시 ParentComponent 리렌더링 */}
      <button onClick={() => setCount(count + 1)}>Increment Parent Count</button>
      {/* handleClick이 재생성되지 않으므로 ChildComponent는 불필요하게 리렌더링되지 않음 */}
      <ChildComponent onClick={handleClick} />
    </div>
  );
}
```