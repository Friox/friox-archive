---
slug: deep-dive-20250408
title: React 기초 - 1
description: React 개발의 핵심 구성 요소인 JSX, Rendering, Component, Props, State, Event, Iteration에 대해 학습한 내용을 정리했습니다.
createAt: 2025-04-08
category: 학습일지
tags: [deepdive, react, frontend]
series: deepdive backend 3rd
---

`markdown:deepdive-info.md`

# JSX

JSX는 ReactElement를 정의하는 간편한 방법으로, 자바스크립트를 확장한 문법이다.  
XML 문법 형식으로 ReactElement를 정의할 수 있게 해준다.
> * `createElement`를 이용해 요소를 정의하면 복잡하고 가독성이 떨어지는데,  
>   JSX를 사용하면 더 쉽고 간결하게 작성할 수 있다.
> * JSX는 공식적인 자바스크립트 문법이 아니므로, Babel과 같은 트랜스파일링 도구가 필요하다.  
>   Babel은 **ES6+** 문법으로 변환해 줄 뿐만 아니라, JSX를 순수 React로 변환해 주는 기능도 제공한다.

## JSX 사용법
1. Babel CDN 구문을 추가한다.
2. `<script>` 태그의 `type` 속성에 `text/babel` 속성값을 추가한다.
```html
<!DOCTYPE html>
<html lang="ko">
<head>
  <!-- ... -->
  <!-- highlight-next-line  -->
  <script crossorigin src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
  <div id="root"></div>
  <!-- highlight-next-line  -->
  <script type="text/babel"></script>
</body>
</html>
```

## JSX 에서 JavaScript 표현식 사용
JSX 문법 내에서는 중괄호(`{}`)를 이용하여 모든 JavaScript 표현식을 사용할 수 있다.
```jsx
const element = <h1>안녕하세요! {getUser(name)}님!</h1>
```

## Fragment
JSX는 편리한 문법이지만 몇가지 규칙을 준수해야한다.  
동일 레벨의 노드들이 연달아 정의되는 경우 문법적인 에러가 발생할 수 있다.  
<br>

여러 형제 레벨의 요소를 정의해야 하는 경우, 하나의 부모 요소로 감싸야만 한다.  
`<div>` 태그와 같이 실질적인 요소를 사용하지 않으려면 React에서 제공하는 `<Fragment>`를 이용할 수 있다.

```jsx
// 최상위 요소가 두 개 이상이면 에러가 발생한다.
const element = (
  <h1>hello</h1>
  <h2>world</h2>
)

// div 또는 <></>, React Fragment로 감싸서 해결한다
const { Fragment } = React
const element = (
  <Fragment>{/* highlight-line */}
    <h1>hello</h1>
    <h2>world</h2>
  </Fragment>{/* highlight-line */}
)
```

## Attribute
JSX를 이용하여 요소를 정의할 때 속성을 지정할 수 있다.  
이벤트 관련 속성은 카멜케이스(camelCase)를 사용해야한다.  
<br>

JSX 문법에서 속성값을 부여하는 방법은 두가지다.
* 문자열로 속성값을 정의하는 방식
* JavaScript 표현식 `{}` 을 이용하여 정의하는 방식
```jsx
const element = <h1 id="title" className="mainTitle"></h1>

const id = "title"
const customClass = "mainTitle"
const element = <h1 id={id} className={mainTitle}></h1>
```

## Inline Styling
JSX에서 Inline Styling을 적용할때는 아래 규칙을 지켜야 한다.
* 케밥케이스(kebab-case)를 카멜케이스(camelCase)로 작성해야한다.
* 속성 값은 문자열 또는 숫자 형태로 작성해야 한다. (객체 X)
* 단위를 생략하면 px단위로 설정된다.
```jsx
const element = <h1 style={{ color: 'white', fontSize: 12 }}>title</h1>
```

## Event Attribute
JSX에서 이벤트 함수를 표현식으로 작성하여 사용할 수 있다.
```jsx
const element = <button onClick={() => { console.log('click!') }}>submit</button>

// 분리해도 괜찮다
const onClickHandler = () => {
  console.log('click')
}
const element = <button onClick={onClickHandler}>submit</button>
```

## JSX에서의 주석 작성법
* HTML 주석 : `<!-- 내용 -->`
* JavaScript 한줄 주석 : `// 내용`
* JavaScript 여러줄 주석 : `/* 내용 */`
* JSX 주석 : `{/* 내용 */}`

# Rendering

React 요소를 루트 DOM 노드에 렌더링 하려면  
`ReactDOM.createRoot(루트 DOM 노드).render(요소)` 를 사용하면 된다.
이때 루트 DOM 안에 들어가는 모든 요소들은 ReactDOM에서 관리하게 된다.  
그래서 이 루트 DOM을 **루트 DOM** 또는 **루트 Node**라고 부른다.
```jsx
ReactDOM.createRoot(document.getElementById('root')).render(element)
```

React 요소는 불변객체(immutable)로, 요소를 생성한 이후에는 해당 요소의 자식이나 속성을 변경할 수 없다.  
따라서 요소를 업데이트하기 위해서는 완전히 새로운 요소를 만들고, `ReactDOM.render` 로 다시 렌더링한다.  
<br>

React 요소는 실제 DOM과 다르게 메모리에서 연산되는 가상 DOM을 사용한다.  
`render` 호출 시 가상 DOM에 새로운 요소를 생성하고 실제 DOM과 비교하여 바뀐 부분만 변경한다.

## 조건부 렌더링
특정 조건에 따라 요소를 다르게 렌더링 할 수 있다.
```jsx
// 조건부 요소 생성
let element
if (answer === 1) element = <h1>positive</h1>
else element = <h1>negative</h1>
root.render(element)

// 삼항연산자 조건부 요소 생성
const element = (answer === 1) ? <h1>positive</h1> : <h1>negative</h1>
root.render(element)

// && 연산자를 이용하여 조건부 요소 생성
// 조건을 만족할때만 요소가 보임
// 0은 false로 취급되지만, 요소 생성 시 0을 반환한다
const element = answer === 1 && <h1>positive</h1>
root.render(element)
```

# Component

컴포넌트는 다른 컴포넌트를 참조할 수 있다. 재사용할 수 있는 최소단위로 유지해야 하며 외부에 영향을 받지않는  
순수함수처럼 작성되어야 한다. 컴포넌트를 생성할 때 다른 컴포넌트를 참조해서 사용하는 것을 컴포넌트 합성이라고 한다.

## 클래스형 컴포넌트
클래스 형태로 요소를 정의할 수 있다.  
사용하는 입장에서는 함수형 컴포넌트가 더 간결과 선언하기도 편하며, 메모리도 덜 사용해서 권장되는 방법이지만,  
State 사용 및 라이프 사이클 기능, 임의의 메소드 정의 등은 클래스 컴포넌트에서만 사용 가능하다.
```jsx
class Comp extends React.Component {
  render(
    <>...</>
  )
}
```

## 함수형 컴포넌트
함수형 컴포넌트는 간결하게 작성할 수 있다는 장점을 가지고 있다.  
함수의 반환값으로 요소를 정의하면된다. (일반적으로 JSX 사용)  
함수의 이름은 반드시 파스칼 케이스(PascalCase)를 사용해야 한다.
```jsx
const Comp = () => <>...</>
```

# Props

Props는 부모 컴포넌트로부터 자식 컴포넌트로 데이터를 전달할 때 사용하는 읽기 전용(immutable) 값이다.  
컴포넌트 외부에서 전달되며, 컴포넌트 내부에서는 변경할 수 없다.

## Props 사용법
*   함수형 컴포넌트에서는 함수의 첫 번째 인자로 `props` 객체를 받는다.
*   클래스형 컴포넌트에서는 `this.props`를 통해 접근한다.

```jsx
// 함수형 컴포넌트
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}

// 클래스형 컴포넌트
class Welcome extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}</h1>;
  }
}

// 컴포넌트 사용 시 props 전달
const element = <Welcome name="name" />;
root.render(element);
```

## Props 특징
* **읽기 전용**: 컴포넌트 내부에서 props를 직접 수정해서는 안 된다.
* **다양한 타입 전달**: 문자열, 숫자, 배열, 객체, 함수 등 다양한 타입의 데이터를 전달할 수 있다.
* **`props.children`**: 컴포넌트 태그 사이에 작성된 내용은 `props.children`으로 전달된다.

```jsx
function Container(props) {
  return <div className="container">{props.children}</div>;
}

const element = (
  <Container>
    <h1>Title</h1>
    <p>This is content.</p>
  </Container>
);
root.render(element);
```

## `defaultProps`, `propTypes`
* `defaultProps`: props의 기본값을 설정할 수 있다. 부모 컴포넌트에서 해당 props를 전달하지 않았을 경우 사용된다.
* `propTypes`: props의 타입을 지정하고 검증할 수 있다. 개발 중 props 타입 관련 오류를 방지하는 데 도움이 된다.  
  (별도 라이브러리 `prop-types` 설치 필요)

```jsx
import PropTypes from 'prop-types'; // prop-types 라이브러리 import

function Greeting({ name }) { // 구조 분해 할당 사용 가능
  return <h1>Hello, {name}</h1>;
}

// 기본값 설정
Greeting.defaultProps = {
  name: 'Stranger'
};

// 타입 검증
Greeting.propTypes = {
  name: PropTypes.string
};

// 사용 예시
root.render(<Greeting />); // "Hello, Stranger" 렌더링
root.render(<Greeting name="Friox" />); // "Hello, Friox" 렌더링
// root.render(<Greeting name={123} />); // 콘솔에 타입 경고 발생
```

# State

State는 컴포넌트 내부에서 관리되는, 변경 가능한 데이터이다.  
State가 변경되면 컴포넌트는 자동으로 리렌더링되어 변경된 내용을 화면에 반영한다.

## State 사용법 (클래스형 컴포넌트)
* 생성자(`constructor`) 내에서 `this.state`를 초기화한다.
* State를 업데이트할 때는 반드시 `this.setState()` 메소드를 사용해야 한다.  
  직접 `this.state`를 수정하면 리렌더링이 일어나지 않는다.
* `setState()`는 비동기적으로 작동할 수 있으며, 여러 `setState` 호출을 하나로 묶어 처리하기도 한다.

```jsx
class Counter extends React.Component {
  constructor(props) {
    super(props);
    // state 초기화
    this.state = { count: 0 };
  }

  increment() {
    // setState를 사용하여 state 업데이트
    this.setState({ count: this.state.count + 1 });
    // 함수형 업데이트 (이전 state 기반 업데이트 시 권장)
    // this.setState((prevState) => ({ count: prevState.count + 1 }));
  }

  render() {
    return (
      <div>
        <p>Count: {this.state.count}</p>
        <button onClick={() => this.increment()}>Increment</button>
      </div>
    );
  }
}

root.render(<Counter />);
```

## State 사용법 (함수형 컴포넌트 - `useState` Hook)
* `useState` Hook을 사용하여 함수형 컴포넌트에서도 state를 관리할 수 있다.
* `useState`는 상태 값과 해당 상태를 업데이트하는 함수를 배열 형태로 반환한다. `[state, setState]`
* 상태 업데이트 함수(`setState`)를 호출하면 컴포넌트가 리렌더링된다.

```jsx
const { useState } = React; // useState Hook import

function Counter() {
  // useState 사용: count 상태와 setCount 업데이트 함수 선언
  const [count, setCount] = useState(0); // 초기값 0

  return (
    <div>
      <p>Count: {count}</p>
      {/* setCount 함수를 호출하여 상태 업데이트 */}
      <button onClick={() => setCount(count + 1)}>Increment</button>
      {/* 함수형 업데이트 */}
      {/* <button onClick={() => setCount(prevCount => prevCount + 1)}>Increment</button> */}
    </div>
  );
}

root.render(<Counter />);
```

## State 특징
* **컴포넌트 내부 관리**: State는 해당 컴포넌트 내에서만 접근하고 수정할 수 있다. (캡슐화)
* **동적 데이터**: 사용자와의 상호작용이나 비동기 요청 결과 등 시간에 따라 변하는 데이터를 관리하는 데 사용된다.
* **리렌더링 유발**: State가 변경되면 React는 해당 컴포넌트와 그 자식 컴포넌트들을 리렌더링한다.

# Event

React의 이벤트 시스템은 웹 브라우저의 기본 DOM 이벤트 시스템과 유사하지만, 몇 가지 차이점을 가진다.  
React는 자체적인 이벤트 시스템(SyntheticEvent)을 구현하여 브라우저 간의 호환성을 높이고 성능을 최적화한다.

## 이벤트 핸들링 방법
* **카멜 케이스(camelCase)**: 이벤트 이름은 카멜 케이스로 작성한다 (예: `onClick`, `onChange`, `onSubmit`).
* **함수 전달**: 이벤트 핸들러로는 문자열이 아닌 함수를 전달한다.
* **기본 동작 방지**: DOM과 마찬가지로 `event.preventDefault()`를 호출하여  
  기본 동작(예: 폼 제출 시 페이지 새로고침)을 막을 수 있다.

```jsx
function ActionButton() {
  function handleClick(event) {
    // event는 SyntheticEvent 객체
    event.preventDefault(); // a 태그의 기본 동작 방지
    console.log('Button clicked!');
  }

  return (
    // onClick 이벤트에 handleClick 함수 연결
    <a href="#" onClick={handleClick}>
      Click Me
    </a>
  );
}

root.render(<ActionButton />);
```

## 이벤트 핸들러에서의 `this` (클래스형 컴포넌트)
클래스형 컴포넌트에서 일반 함수를 이벤트 핸들러로 사용하면 `this`가 `undefined`가 되는 문제가 발생할 수 있다.  
(함수형 컴포넌트에선 문제가 발생하지 않음!)  
이를 해결하는 방법은 다음과 같다.
1.  **생성자에서 바인딩**: `constructor`에서 명시적으로 바인딩한다.
2.  **화살표 함수 사용 (클래스 속성)**: 클래스 속성으로 화살표 함수를 정의하면 `this`가 자동으로 바인딩된다. (권장)
3.  **렌더링 시 화살표 함수 사용**: 렌더링 시점에 화살표 함수로 감싸서 호출한다. 컴포넌트가 렌더링될 때마다 새로운 함수가 생성되므로 성능상 단점이 있을 수 있다.

```jsx
class Toggle extends React.Component {
  constructor(props) {
    super(props);
    this.state = { isToggleOn: true };

    // 방법 1: 생성자에서 바인딩
    // this.handleClick = this.handleClick.bind(this);
  }

  // 방법 2: 클래스 속성으로 화살표 함수 사용 (권장)
  handleClick = () => {
    this.setState(prevState => ({
      isToggleOn: !prevState.isToggleOn
    }));
  }

  render() {
    return (
      <button onClick={this.handleClick}>
      {/* 방법 3: 렌더링 시 화살표 함수 사용 */}
      {/* <button onClick={(e) => this.handleClick(e)}> */}
        {this.state.isToggleOn ? 'ON' : 'OFF'}
      </button>
    );
  }
}

root.render(<Toggle />);
```

# Iteration

배열 데이터를 기반으로 여러 개의 동일한 구조를 가진 컴포넌트 목록을 렌더링할 때 사용한다.  
JavaScript의 `map()` 함수를 활용하는 것이 일반적이다.

## `map()` 함수 사용
배열의 각 요소를 순회하며 JSX 요소를 생성하고, 이 요소들의 배열을 반환하여 렌더링한다.

```jsx
const numbers = [1, 2, 3, 4, 5];

function NumberList(props) {
  const listItems = props.numbers.map((number) =>
    // 각 리스트 아이템을 li 요소로 변환
    <li>{number}</li>
  );

  return (
    <ul>{listItems}</ul>
  );
}

root.render(<NumberList numbers={numbers} />);
```

## `key` Prop
배열을 사용하여 여러 요소를 렌더링할 때는 각 요소에 고유한 `key` prop을 반드시 지정해야 한다.
* **역할**: `key`는 React가 어떤 항목을 변경, 추가 또는 삭제할지 식별하는 데 도움을 준다.
* **고유성**: `key`는 형제 요소 사이에서만 고유하면 된다. 전체 애플리케이션에서 고유할 필요는 없다.
* **값 선택**: 데이터에 각 항목을 고유하게 식별할 수 있는 ID가 있다면 그것을 `key`로 사용하는 것이 가장 좋다.  
  단, 인덱스는 리스트의 순서가 바뀌거나 항목이 추가/삭제될 때 성능 문제나  
  state 관련 버그가 발생할 수 있으므로 권장되지 않는다.

```jsx
const todos = [
  { id: 1, text: '값 1' },
  { id: 2, text: '값 2' },
  { id: 3, text: '값 3' }
];

function TodoList(props) {
  const todoItems = props.todos.map((todo) =>
    // 각 todo 객체의 id를 key로 사용
    // highlight-next-line
    <li key={todo.id}>
      {todo.text}
    </li>
  );

  return (
    <ul>{todoItems}</ul>
  );
}

root.render(<TodoList todos={todos} />);
```

`key`는 React 내부에서만 사용되며, 컴포넌트로 전달되지 않는다.  
만약 `key`와 동일한 값이 컴포넌트 내부에서 필요하다면 별도의 prop(예: `id={todo.id}`)으로 전달해야 한다.
